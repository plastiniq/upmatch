const OAuth = require('oauth')
const baseUrl = process.env.UPWORKAPI || 'https://www.upwork.com'
const URL = require('url')
const qs = require('querystring')

export default class {

  constructor (key, secret) {
      this.requestUrl = baseUrl + '/api/auth/v1/oauth/token/request'
      this.accessUrl = baseUrl + '/api/auth/v1/oauth/token/access'
      this.key = key
      this.baseUrl = baseUrl
      this.secret = secret
      this.version = '1.0'
      this.callback = null
      this.signatureMethod = 'HMAC-SHA1'
      this.nonceSize = 32
      this.customHeaders = {
          'Accept' : 'application/json',
          'Connection' : 'close',
          'User-Agent': 'Node-Upwork'
      }

      this.o = new OAuth.OAuth(this.requestUrl, this.accessUrl, this.key, this.secret, this.version, this.callback, this.signatureMethod, this.nonceSize, this.customHeaders)
  }

  getRequestToken() {
    return new Promise((resolve, reject) => {
      this.o.getOAuthRequestToken((error, requestToken, requestTokenSecret) => {
        if (error) {
          reject(error)
        } else {
          resolve({ requestToken, requestTokenSecret })
        }
      })
    })
  }

  getAccessToken(requestToken, requestTokenSecret, verifier) {
    return new Promise((resolve, reject) => {
      this.o.getOAuthAccessToken(requestToken, requestTokenSecret, verifier, function(error, accessToken, accessTokenSecret) {
        if (error) {
          reject(error)
        }
        else {
          resolve({
            accessToken,
            accessTokenSecret
          })
        }
      })
    })
  }

  getAuthorizeUrl(callbackUrl, requestToken, requestTokenSecret) {
    return new Promise((resolve, reject) => {
      var authorizeUrl = baseUrl + '/services/api/auth'

      var params = {
        oauth_callback: callbackUrl
      }
  
      if (requestToken && requestTokenSecret) {
        params.oauth_token = requestToken;
        resolve({
          url: authorizeUrl + '?' + qs.stringify(params),
          requestToken, 
          requestTokenSecret
        })
      } 
      else {
        this.getRequestToken().then(resp => {
          params.oauth_token = resp.requestToken
          resolve({
            url: authorizeUrl + '?' + qs.stringify(params),
            requestToken: resp.requestToken, 
            requestTokenSecret: resp.requestTokenSecret
          })
        }).catch(error => reject(error))
      }
    })
  }

  fetch (method, path, data, accessToken, accessTokenSecret) {
    var attempt = 0

    return this.fetchRaw(method, path, data, accessToken, accessTokenSecret).catch(error => {
      if (error.status === 429 && attempt < 100) {
        attempt++
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            this.fetch(method, path, data, accessToken, accessTokenSecret).then(resp => resolve(resp)).catch(error => reject(error))
          }, 200)
        })
      } else {
        return Promise.reject(error)
      }
    })
  }

  fetchRaw (method, path, data, accessToken, accessTokenSecret) {
    if (!(accessToken && accessTokenSecret)) {
      return Promise.reject({ status: 401, statusText: 'Missed access tokens' })
    }

    return new Promise((resolve, reject) => {
      var extraParams = {}
      if (method != 'GET') {
        extraParams = data || {}
        data = null;
        if (method == 'PUT' || method == 'DELETE') {
            extraParams['http_method'] = method.toLowerCase()
            method = 'POST'
        }
      } 
      else if (data) {
          path += (path.indexOf('?') == -1) ? '?' : '&';
          path += qs.stringify(data)
          data = null;
      }
      var url = URL.resolve(this.baseUrl, path);
      var requestHandler = (error, responseData, response) => {
        
        if (response.statusCode >= 400) {
          return reject({ status: response.statusCode, statusText: response.statusMessage, data: responseData })
        }

        if (error) {
          return reject({ status: 400, statusText: error, data: responseData })
        }
        else {
          if (response.headers['content-type'] == 'application/json') {
            try {
              var json = JSON.parse(responseData)
            } 
            catch(error) {
              return reject({ status: 400, statusText: error, data: responseData })
            }
            return resolve(json)
          } 
          else {
            return resolve(responseData)
          }
        }
      }

      this.o._performSecureRequest(accessToken, accessTokenSecret, method, url, extraParams, data, null, requestHandler)
    })
  }
}